#include "bigint.h"


int main__()
{
	// | 0000 0001 | ffff ffff | 
	//uint64 i = 0x1ffffffff;		//8589934591;
	
	uint32 number[] = {0x00000001,0x00000000,0x00000000};//18446744073709551616(10进制)
  //uint32 number[] = {0x00000000,0xffffffff,0xffffffff};//18446744073709551615(10进制)
	uint32 number_size= sizeof(number)/sizeof(uint32);
 
	uint64 quotient =0;//商
	uint64 remainder=0;//余数
	uint32 index = 0;

	uint32 number2[3] = {0};
	do
	{
		uint64 v = 0;
		do 
		{
			v = number[index];
			v = v + remainder * 0x0000000100000000;
			quotient = v / 10;
			remainder =  v % 10;

			printf("%lld,%lld	\n",quotient,remainder);

			number[index] = quotient;

		} while ( ++index< number_size );//remainder>0);

		index = 0;

	}while(remainder);

	return 0;
}

//获得最高位不为0的bit的序数: 63 ~ 0
uint32 get_non_zero_bit_idx(uint64 v)
{
	for (int idx=63;idx>=0;idx--)
	{
		if ( (v>>idx) & 1)
		{
			return idx;
		}
	}
	return -1;
}

/*
  v = 1894780912
  d = 1044720
  v/d = 1813.6734359446

  1813 二进制为 11100010101

  v : 01110000 11110000 00001111 11110000 na = 30  : 1894780912
  d :              1111 11110000 11110000 nb = 19  :    1044720
  d':  1111111 10000111 10000000 00000000  d<<11   : 2139586560
	  -----------------------------------  不够减
	  
	  c = 0;

  v : 01110000 11110000 00001111 11110000 na = 30 : 1894780912
  d :              1111 11110000 11110000 nb = 19 :    1044720
  d':   111111 11000011 11000000 00000000   d<<10 : 1069793280
	  -----------------------------------  够减   :  
	  c = 1;

  v :   110001 00101100 01001111 11110000 na = 29 :  824987632
  d :              1111 11110000 11110000 nb = 19 :    1044720		
  d':   111111 11000011 11000000 00000000 d<<10   : 1069793280
	  -----------------------------------  不够减 :        
	 c = 0;

  v :   110001 00101100 01001111 11110000 na = 29 :  824987632
  d :              1111 11110000 11110000 nb = 19 :    1044720		
  d':    11111 11100001 11100000 00000000 d<<9   :   534896640
  -----------------------------------  够减 :    
	c = 1;

  v :    10001 01001010 01101111 11110000 na = 28 :  290090992
  d :              1111 11110000 11110000 nb = 19 :    1044720		
  d':     1111 11110000 11110000 00000000 d<<9   :   534896640
  -----------------------------------  不够减 :    
    c = 0;

  v :    10001 01001010 01101111 11110000 na = 28 :  290090992
  d :              1111 11110000 11110000 nb = 19 :    1044720		
  d':      111 11111000 01111000 00000000 d<<8   :   267448320
  -----------------------------------  够减 :    
    c = 1;

  v :        1 01011001 01111111 11110000 na = 24 :   22642672
  d :              1111 11110000 11110000 nb = 19 :    1044720		
  d':        1 11111110 00011110 00000000  d<<5   :   33431040
  -----------------------------------  不够减 :    
    c = 0;

  v :        1 01011001 01111111 11110000 na = 24 :   22642672
  d :              1111 11110000 11110000 nb = 19 :    1044720		
  d':          11111111 00001111 00000000  d<<4   :   16715520
  -----------------------------------  够减 :   
  c = 1;

  v :           1011010 01110000 11110000 na = 22 :    5927152
  d :              1111 11110000 11110000 nb = 19 :    1044720		
  d':           1111111 10000111 10000000  d<<3   :    8357760
  -----------------------------------  不够减 :  
  c = 0;

  v :           1011010 01110000 11110000 na = 22 :    5927152
  d :              1111 11110000 11110000 nb = 19 :    1044720		
  d':            111111 11000011 11000000  d<<2   :    4178880
  -----------------------------------  够减 :  
  c = 1;

  v :             11010 10101101 00110000 na = 20 :    1748272
  d :              1111 11110000 11110000 nb = 19 :    1044720		
  d':             11111 11100001 11100000  d<<1   :    2089440
  -----------------------------------  不够减 :  
  c = 0;

  v :             11010 10101101 00110000 na = 20 :    1748272
  d :              1111 11110000 11110000 nb = 19 :    1044720		
  d':              1111 11110000 11110000  d<<0   :    1044720
  -----------------------------------  够减 :  
  c = 1;

  v :              1010 10111100 01000000 na = 19 :     703552
  d :              1111 11110000 11110000 nb = 19 :    1044720		
  d':              1111 11110000 11110000  d<<0   :    1044720
  -----------------------------------  不够减 :  
  c = 0;

*/
//v 被除数 d 除数 q 商 r 余数
uint64  binary_div(int64 a,int64 b,uint64 &q,uint64&r)
{
	int na = 0;
	int nb = 0;
	int c = 0;
	na = get_non_zero_bit_idx(a);
	nb = get_non_zero_bit_idx(b);

	while (a>=b) // so that diff >= 0
	{
		na = get_non_zero_bit_idx(a);
		int diff = na - nb;
		
		while(diff>0 && a<(b<<diff)) //so that a >= b<<diff
			diff--;
		if (a >= (b<<diff) )
		{
			c = c + (1<<diff);	
		}				
		a = a - (b<<diff);
	}
	q = c;
	r = a;
	return c;
}

//http://blog.csdn.net/wangjian8006/article/details/7833228
//http://blog.sbw.so/Article/index/title/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0.html

int g_x,g_y;
//euclid算出来的是 a*x + b*y = gcd(a,b)的解
//对于a 和 b互质的情况，就是a*x + b*y = gcd(a,b) === 1的解
void euclid(int a,int b)
{
	int old_a = a;
	int old_b = b;
	int tmp = b;
	b = a % b;
	a = tmp;
	if(b == 0)
	{
		g_x = 1;
		g_y = 0;

		//最后一次递归返回时，顺带把出了赋予初始值之外的
		//第一层x y之间的递推也计算出来。
		int tmp = g_x;
		g_x = g_y;
		g_y = tmp - (old_a/old_b)*g_y;
		return;
	}
	
	euclid(a,b);
	
	//计算第一次
	int old_x = g_x;
	g_x = g_y;
	g_y = old_x - (old_a/old_b)*g_y;
}
int main()
{
	BigInt xxx,yyy;
	BigInt aaa("47");
	BigInt bbb("30");

	ExEuclid(aaa,bbb,xxx,yyy);
	euclid(47,30);
	euclid(300,420);
	euclid(11,49);
	euclid(11,7);
	int32 idx = -1;
	//BigInt ii("4294967295");
	//BigInt iii("4294967296");
	BigInt   iiii("18446744065119617025");
	iiii.Dump();
 
	BigInt  iiiii("18446744073709551615");
	iiiii.Dump();
	 
	BigInt iiiiii("18446744073709551616");
	iiiiii.Dump();
	 
	BigInt iiiiiii("184467440737095516161844674407370955161618446744073709551616184467440737095516161844674407370955161618446744073709551616");
	iiiiiii.Dump();
	 
 
	BigInt iiiiiiii("18446744073709551616184467440737095516161844674407370955161618446744073709551616184467440737095516161844674407370955161");
	iiiiiiii.Dump();

	int res = iiiiiii.Compare(iiiiiiii);
	printf("%d \n",res);
	

	uint64 u64 = 1;
	u64 = u64 << 33;

	uint32 u32 = 1;
	u32 = u32 << 33;

	uint64 q,r;

	for ( int i=0;i<=-100;i++)
	{
		int v = rand()%1000 + 1;
		int d = rand() % 100 + 1;
		binary_div(v,d,q,r);
		std::cout<<v<<" "<<d<<" "<< (v / d) <<" : "<< q <<" "<<r<< " d * q + r:"<<d*q + r <<std::endl;
	}
	//binary_div(0xe8e,0x12,q,r);
	//binary_div(81,1,q,r);
	//binary_div(1894780912,1044720,q,r);
	binary_div(38,60,q,r);

	if ( BigInt("81698111990267904") < BigInt("73183493944770559") )
	{
		printf("compare error!!!!!!");
	}


	BigInt X("123018668453011775513049495838496272077285356959533479219732245215172640050726365751874520219978646938995647494277406384592519255732630345373154826850791702612214291346167042921431160222124047927473779408066535141959745985690214341312301866845301177551304949583849627207728535695953347921973224521517264005072636575187452021997864693899564749427740638459251925573263034537315482685079170261221429134616704292143116022212404792747377940806653514195974598569021434131230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413123018668453011775513049495838496272077285356959533479219732245215172640050726365751874520219978646938995647494277406384592519255732630345373154826850791702612214291346167042921431160222124047927473779408066535141959745985690214341312301866845301177551304949583849627207728535695953347921973224521517264005072636575187452021997864693899564749427740638459251925573263034537315482685079170261221429134616704292143116022212404792747377940806653514195974598569021434131230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413123018668453011775513049495838496272077285356959533479219732245215172640050726365751874520219978646938995647494277406384592519255732630345373154826850791702612214291346167042921431160222124047927473779408066535141959745985690214341312301866845301177551304949583849627207728535695953347921973224521517264005072636575187452021997864693899564749427740638459251925573263034537315482685079170261221429134616704292143116022212404792747377940806653514195974598569021434131230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413123018668453011775513049495838496272077285356959533479219732245215172640050726365751874520219978646938995647494277406384592519255732630345373154826850791702612214291346167042921431160222124047927473779408066535141959745985690214341312301866845301177551304949583849627207728535695953347921973224521517264005072636575187452021997864693899564749427740638459251925573263034537315482685079170261221429134616704292143116022212404792747377940806653514195974598569021434131230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413123018668453011775513049495838496272077285356959533479219732245215172640050726365751874520219978646938995647494277406384592519255732630345373154826850791702612214291346167042921431160222124047927473779408066535141959745985690214341312301866845301177551304949583849627207728535695953347921973224521517264005072636575187452021997864693899564749427740638459251925573263034537315482685079170261221429134616704292143116022212404792747377940806653514195974598569021434131230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413123018668453011775513049495838496272077285356959533479219732245215172640050726365751874520219978646938995647494277406384592519255732630345373154826850791702612214291346167042921431160222124047927473779408066535141959745985690214341312301866845301177551304949583849627207728535695953347921973224521517264005072636575187452021997864693899564749427740638459251925573263034537315482685079170261221429134616704292143116022212404792747377940806653514195974598569021434131230186684530117755130494958384962720772853569595334792197322452151726400507263657518745202199786469389956474942774063845925192557326303453731548268507917026122142913461670429214311602221240479274737794080665351419597459856902143413");
	BigInt Y("7944334226403768");//("33478071698956898786044169848212690817704794983713768568912431388982883793878002287614711652531743087737814467999489");

	BigInt MulR ;
	MulR = Mul(X,Y);
	MulR.Dump("乘法结果为:");

	//result = 7944334226403768
	BigInt Tmp("7944334226403768"); // 7944334226403768
	Tmp.Dump();
	BigInt Q;
	BigInt Result;
	BigInt R;


	Result = BigDiv(X,Y,Q,R);
	Result.Dump("除法结果为:");
	R.Dump("余数为:");

	BigInt eee;
	eee = GCD(X,Y);
	eee.Dump("最大公约数为");

	//测试最大公约数
	BigInt mmm = Mod(X,eee);
	mmm.Dump("X mod结果：");
	BigInt nnn = Mod(Y,eee);
	nnn.Dump("Y mod结果：");


	


	return 0;
}